


  
  
  HidrataX Pac-Man
  
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

<pre><code>body {
  background: #000000;
  color: #FFFFFF;
  min-height: 100vh;
  padding: 20px;
  overflow-x: hidden;
  position: relative;
  font-family: &#39;Arcade Classic&#39;, monospace;
}

.stars {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}

.header {
  text-align: center;
  margin-bottom: 20px;
}

h1 {
  font-family: &#39;Press Start 2P&#39;, monospace;
  font-size: 2.5rem;
  color: #FFFF00;
  text-shadow: 0 0 8px #FFFF00, 0 0 16px #FF0000;
}

.main {
  display: flex;
  gap: 20px;
  max-width: 1280px;
  margin: 0 auto;
  flex-wrap: wrap;
  justify-content: center;
}

.tracker {
  background: #0000FF;
  border-radius: 10px;
  padding: 20px;
  width: 100%;
  max-width: 350px;
  text-align: center;
  border: 2px solid #FFFF00;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
}

input {
  padding: 10px;
  margin: 8px;
  border: 2px solid #FFFF00;
  border-radius: 8px;
  background: #000000;
  color: #FFFFFF;
  font-family: &#39;Arcade Classic&#39;, monospace;
  font-size: 1.2rem;
  width: 140px;
}

button {
  background: linear-gradient(45deg, #FF0000, #FF5555);
  color: #FFFFFF;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-family: &#39;Arcade Classic&#39;, monospace;
  font-size: 1.2rem;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

button:hover {
  transform: scale(1.1);
  box-shadow: 0 0 12px #FF0000;
}

.stats {
  font-size: 1.2rem;
  margin-top: 15px;
  color: #00FF00;
  line-height: 1.6;
  text-shadow: 0 0 4px #00FF00;
}

canvas {
  border: 2px solid #FFFF00;
  background: #000000;
  margin-top: 20px;
  max-width: 100%;
  display: none;
  border-radius: 8px;
  box-shadow: 0 0 16px rgba(255, 255, 0, 0.5);
}

canvas.active {
  display: block;
}

.controls {
  display: none;
  margin-top: 15px;
  gap: 12px;
  justify-content: center;
}

.controls button {
  width: 80px;
  height: 80px;
  font-size: 1.8rem;
  background: linear-gradient(45deg, #FF00FF, #FF55FF);
  border: 2px solid #FFFF00;
}

.controls button:hover {
  box-shadow: 0 0 12px #FF00FF;
}

/* Estilos para Web */
@media (min-width: 768px) {
  h1 {
    font-size: 3.5rem;
    animation: neon 1.5s ease-in-out infinite alternate;
  }
  @keyframes neon {
    from { text-shadow: 0 0 8px #FFFF00, 0 0 16px #FF0000, 0 0 24px #FF0000; }
    to { text-shadow: 0 0 12px #FFFF00, 0 0 24px #FF0000, 0 0 36px #FF0000; }
  }
  .main {
    flex-wrap: nowrap;
  }
  .tracker {
    max-width: 320px;
  }
  canvas {
    width: 640px;
    height: 480px;
  }
  .stars {
    background: linear-gradient(180deg, #000000 0%, rgba(0, 0, 0, 0.8) 100%);
  }
}

/* Estilos para Mobile */
@media (max-width: 767px) {
  h1 {
    font-size: 2rem;
    animation: pulse 2s ease-in-out infinite;
  }
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  .main {
    flex-direction: column;
    align-items: center;
  }
  .tracker {
    max-width: 100%;
  }
  canvas {
    width: 100%;
    height: 300px;
  }
  .controls {
    display: flex;
  }
}

@media (max-width: 400px) {
  input {
    width: 120px;
    font-size: 1rem;
  }
  button {
    padding: 10px 20px;
    font-size: 1rem;
  }
  .controls button {
    width: 60px;
    height: 60px;
    font-size: 1.5rem;
  }
}
</code></pre>
<p>    


  
  
    HidrataX Pac-Man
  
  
    
      
        ML por dose:
        
        Volume de √°gua por dose em mililitros
      
      Beber √Ågua üíß
      
      
        ‚Üë
        ‚Üì
        ‚Üê
        ‚Üí
      
    
    
  

  
    // Configura√ß√£o inicial
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    // Ajuste responsivo do canvas
    function ajustarCanvas() {
      canvas.width = Math.min(640, window.innerWidth - 40);
      canvas.height = canvas.width * 0.75;
      ajustarLabirinto();
    }
    window.addEventListener('resize', ajustarCanvas);

    // Estado do jogo
    const mapaBase = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
      [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
      [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
      [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    let cellSize, offsetX, offsetY;
    function ajustarLabirinto() {
      cellSize = Math.min(canvas.width / mapaBase[0].length, canvas.height / mapaBase.length);
      offsetX = (canvas.width - mapaBase[0].length * cellSize) / 2;
      offsetY = (canvas.height - mapaBase.length * cellSize) / 2;
    }
    ajustarCanvas();

    // Estrelas de fundo
    const starsCanvas = document.createElement('canvas');
    starsCanvas.width = window.innerWidth;
    starsCanvas.height = window.innerHeight;
    document.getElementById('stars').appendChild(starsCanvas);
    const starsCtx = starsCanvas.getContext('2d');
    const coresAtari = ['#FFFF00', '#00FF00', '#00FFFF', '#FF00FF'];
    const estrelas = [];
    for (let i = 0; i < 50; i++) {
      estrelas.push({
        x: Math.random() * starsCanvas.width,
        y: Math.random() * starsCanvas.height,
        size: Math.random() * 2 + 1,
        speed: Math.random() * 0.3 + 0.2,
        color: coresAtari[Math.floor(Math.random() * coresAtari.length)]
      });
    }
    function animarEstrelas() {
      starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
      estrelas.forEach(estrela => {
        starsCtx.fillStyle = estrela.color;
        starsCtx.beginPath();
        starsCtx.arc(estrela.x, estrela.y, estrela.size, 0, Math.PI * 2);
        starsCtx.fill();
        estrela.x -= estrela.speed * (window.innerWidth > 767 ? 0.6 : 0.3);
        if (estrela.x < 0) {
          estrela.x = starsCanvas.width;
          estrela.color = coresAtari[Math.floor(Math.random() * coresAtari.length)];
        }
      });
      requestAnimationFrame(animarEstrelas);
    }
    animarEstrelas();

    // Dados persistentes
    const hoje = new Date().toLocaleDateString();
    let dados = JSON.parse(localStorage.getItem('hidrataX')) || {};
    if (!dados[hoje]) dados[hoje] = { agua: 0, pontos: 0, vidas: 0 };
    let vidas = dados[hoje].vidas;
    let aguaHoje = dados[hoje].agua;
    let pontos = dados[hoje].pontos;
    let gameOver = false;
    let canPlay = vidas > 0;
    let feedbackText = '';
    let feedbackTimer = 0;

    // Estado do Pac-Man
    let pacman = {
      x: 1.5,
      y: 1.5,
      size: 0.4,
      vx: 0,
      vy: 0,
      speed: 0.1,
      angle: 0,
      mouth: 0
    };
    let fantasmas = [
      { x: 9, y: 7, vx: 0, vy: 0, color: '#FF0000', blink: 0, lastDir: null },
      { x: 10, y: 7, vx: 0, vy: 0, color: '#00FF00', blink: 0, lastDir: null },
      { x: 9, y: 8, vx: 0, vy: 0, color: '#00FFFF', blink: 0, lastDir: null },
      { x: 10, y: 8, vx: 0, vy: 0, color: '#FF00FF', blink: 0, lastDir: null }
    ];
    let bolinhas = [];
    let frutas = [];
    let controles = { up: false, down: false, left: false, right: false };

    // Fun√ß√£o para encontrar dire√ß√µes v√°lidas
    function direcoesValidas(x, y, lastDir) {
      const direcoes = [];
      if (y > 0 && mapaBase[y - 1][x] === 0 && lastDir !== 'down') direcoes.push({ vx: 0, vy: -0.075, dir: 'up' });
      if (y < mapaBase.length - 1 && mapaBase[y + 1][x] === 0 && lastDir !== 'up') direcoes.push({ vx: 0, vy: 0.075, dir: 'down' });
      if (x > 0 && mapaBase[y][x - 1] === 0 && lastDir !== 'right') direcoes.push({ vx: -0.075, vy: 0, dir: 'left' });
      if (x < mapaBase[0].length - 1 && mapaBase[y][x + 1] === 0 && lastDir !== 'left') direcoes.push({ vx: 0.075, vy: 0, dir: 'right' });
      return direcoes;
    }

    // Inicializar bolinhas e frutas
    function resetPacman() {
      pacman.x = 1.5;
      pacman.y = 1.5;
      pacman.vx = 0;
      pacman.vy = 0;
      pacman.angle = 0;
      fantasmas = [
        { x: 9, y: 7, vx: 0, vy: 0, color: '#FF0000', blink: 0, lastDir: null },
        { x: 10, y: 7, vx: 0, vy: 0, color: '#00FF00', blink: 0, lastDir: null },
        { x: 9, y: 8, vx: 0, vy: 0, color: '#00FFFF', blink: 0, lastDir: null },
        { x: 10, y: 8, vx: 0, vy: 0, color: '#FF00FF', blink: 0, lastDir: null }
      ];
      bolinhas = [];
      frutas = [];
      const frutasEmojis = ['üçé', 'üçê', 'üçä', 'üçá'];
      for (let y = 0; y < mapaBase.length; y++) {
        for (let x = 0; x < mapaBase[0].length; x++) {
          if (mapaBase[y][x] === 0) {
            bolinhas.push({ x: x + 0.5, y: y + 0.5, size: 0.15 });
            if (Math.random() < 0.05 && !(x === 1 && y === 1)) {
              frutas.push({ x: x + 0.5, y: y + 0.5, emoji: frutasEmojis[Math.floor(Math.random() * frutasEmojis.length)] });
            }
          }
        }
      }
    }

    // Fun√ß√£o de hidrata√ß√£o
    function beberAgua() {
      const ml = parseInt(document.getElementById('ml').value);
      if (isNaN(ml) || ml <= 0) {
        alert('Insira um volume v√°lido!');
        return;
      }
      aguaHoje += ml;
      pontos += Math.floor(ml / 100);
      vidas = Math.min(vidas + 1, 5);
      canPlay = true;
      gameOver = false;
      canvas.classList.add('active');
      resetPacman();
      dados[hoje] = { agua: aguaHoje, pontos, vidas };
      localStorage.setItem('hidrataX', JSON.stringify(dados));
      atualizarStatus();
      if (canPlay && !gameOver) loop();
    }

    function atualizarStatus() {
      statusEl.innerHTML = `
        Pontos: ${pontos}<br>
        √Ågua: ${aguaHoje / 1000} L<br>
        Vidas: ${'‚ù§Ô∏è'.repeat(vidas)}
      `;
      canvas.classList.toggle('active', canPlay && !gameOver);
    }

    // Loop do jogo
    function loop() {
      if (!canPlay || gameOver) {
        canvas.classList.remove('active');
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Desenhar labirinto
      ctx.fillStyle = '#0000FF';
      for (let y = 0; y < mapaBase.length; y++) {
        for (let x = 0; x < mapaBase[0].length; x++) {
          if (mapaBase[y][x] === 1) {
            ctx.fillRect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, cellSize);
          }
        }
      }

      // Desenhar bolinhas
      ctx.fillStyle = '#FFFF00';
      bolinhas.forEach(b => {
        ctx.beginPath();
        ctx.arc(offsetX + b.x * cellSize, offsetY + b.y * cellSize, b.size * cellSize, 0, Math.PI * 2);
        ctx.fill();
      });

      // Desenhar frutas
      ctx.font = `${cellSize * 0.5}px Arial`;
      frutas.forEach(f => {
        ctx.fillStyle = '#FF00FF';
        ctx.fillText(f.emoji, offsetX + f.x * cellSize - cellSize * 0.3, offsetY + f.y * cellSize + cellSize * 0.2);
      });

      // Desenhar Pac-Man
      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();
      pacman.mouth = Math.sin(Date.now() / 80) * 0.5 + 0.5;
      ctx.arc(offsetX + pacman.x * cellSize, offsetY + pacman.y * cellSize, pacman.size * cellSize, pacman.angle + pacman.mouth, pacman.angle + 2 * Math.PI - pacman.mouth);
      ctx.lineTo(offsetX + pacman.x * cellSize, offsetY + pacman.y * cellSize);
      ctx.fill();

      // Desenhar e mover fantasmas
      fantasmas.forEach(f => {
        // Movimento dos fantasmas
        if (Math.abs(f.x - Math.round(f.x)) < 0.005 && Math.abs(f.y - Math.round(f.y)) < 0.005) {
          f.x = Math.round(f.x);
          f.y = Math.round(f.y);
          const direcoes = direcoesValidas(f.x, f.y, f.lastDir);
          if (direcoes.length > 0) {
            let dx = pacman.x - f.x;
            let dy = pacman.y - f.y;
            let bestDir = direcoes[0];
            let minDist = Infinity;
            direcoes.forEach(dir => {
              let newX = f.x + dir.vx;
              let newY = f.y + dir.vy;
              let dist = Math.hypot(pacman.x - newX, pacman.y - newY);
              if (dist < minDist) {
                minDist = dist;
                bestDir = dir;
              }
            });
            let chosenDir = Math.random() < 0.8 ? bestDir : direcoes[Math.floor(Math.random() * direcoes.length)];
            f.vx = chosenDir.vx;
            f.vy = chosenDir.vy;
            f.lastDir = chosenDir.dir;
          } else {
            f.vx = 0;
            f.vy = 0;
            f.lastDir = null;
          }
        }
        f.x += f.vx;
        f.y += f.vy + Math.sin(Date.now() / 200) * 0.015;
        f.blink = (f.blink + 0.05) % 1;
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.arc(offsetX + f.x * cellSize, offsetY + f.y * cellSize, 0.4 * cellSize, 0, Math.PI);
        ctx.lineTo(offsetX + (f.x + 0.4) * cellSize, offsetY + (f.y + 0.4) * cellSize);
        ctx.lineTo(offsetX + (f.x - 0.4) * cellSize, offsetY + (f.y + 0.4) * cellSize);
        ctx.fill();
        ctx.fillStyle = f.blink < 0.8 ? '#FFFFFF' : '#000000';
        ctx.fillRect(offsetX + (f.x - 0.25) * cellSize, offsetY + (f.y - 0.1) * cellSize, 0.12 * cellSize, 0.12 * cellSize);
        ctx.fillRect(offsetX + (f.x + 0.1) * cellSize, offsetY + (f.y - 0.1) * cellSize, 0.12 * cellSize, 0.12 * cellSize);
      });

      // Movimento do Pac-Man
      let novoX = pacman.x + pacman.vx;
      let novoY = pacman.y + pacman.vy;
      let cellX = Math.floor(novoX);
      let cellY = Math.floor(novoY);
      if (cellX >= 0 && cellX < mapaBase[0].length && cellY >= 0 && cellY < mapaBase.length && mapaBase[cellY][cellX] === 0) {
        pacman.x = novoX;
        pacman.y = novoY;
      }
      if (controles.up && mapaBase[Math.floor(pacman.y - 0.5)][Math.floor(pacman.x)] === 0) {
        pacman.vx = 0;
        pacman.vy = -pacman.speed;
        pacman.angle = Math.PI * 1.5;
      } else if (controles.down && mapaBase[Math.floor(pacman.y + 0.5)][Math.floor(pacman.x)] === 0) {
        pacman.vx = 0;
        pacman.vy = pacman.speed;
        pacman.angle = Math.PI * 0.5;
      } else if (controles.left && mapaBase[Math.floor(pacman.y)][Math.floor(pacman.x - 0.5)] === 0) {
        pacman.vx = -pacman.speed;
        pacman.vy = 0;
        pacman.angle = Math.PI;
      } else if (controles.right && mapaBase[Math.floor(pacman.y)][Math.floor(pacman.x + 0.5)] === 0) {
        pacman.vx = pacman.speed;
        pacman.vy = 0;
        pacman.angle = 0;
      } else {
        if (Math.abs(pacman.x - Math.round(pacman.x)) < 0.005 && Math.abs(pacman.y - Math.round(pacman.y)) < 0.005) {
          pacman.x = Math.round(pacman.x);
          pacman.y = Math.round(pacman.y);
          pacman.vx = 0;
          pacman.vy = 0;
        }
      }

      // Colis√£o com bolinhas
      bolinhas.forEach(b => {
        if (Math.hypot(pacman.x - b.x, pacman.y - b.y) < (pacman.size + b.size) / 2) {
          bolinhas = bolinhas.filter(bol => bol !== b);
          pontos += 1;
          aguaHoje += 10;
          dados[hoje].agua = aguaHoje;
          dados[hoje].pontos = pontos;
          localStorage.setItem('hidrataX', JSON.stringify(dados));
          feedbackText = 'Waka Waka';
          feedbackTimer = 60;
          atualizarStatus();
        }
      });

      // Colis√£o com frutas
      frutas.forEach(f => {
        if (Math.hypot(pacman.x - f.x, pacman.y - f.y) < pacman.size / 2 + 0.4) {
          frutas = frutas.filter(fruta => fruta !== f);
          pontos += 5;
          aguaHoje += 50;
          dados[hoje].agua = aguaHoje;
          dados[hoje].pontos = pontos;
          localStorage.setItem('hidrataX', JSON.stringify(dados));
          feedbackText = 'Fruta!';
          feedbackTimer = 60;
          atualizarStatus();
        }
      });

      // Colis√£o com fantasmas
      fantasmas.forEach(f => {
        if (Math.hypot(pacman.x - f.x, pacman.y - f.y) < pacman.size / 2 + 0.4) {
          vidas--;
          dados[hoje].vidas = vidas;
          localStorage.setItem('hidrataX', JSON.stringify(dados));
          atualizarStatus();
          if (vidas <= 0) {
            gameOver = true;
            canPlay = false;
          } else {
            resetPacman();
          }
        }
      });

      // Completar n√≠vel
      if (bolinhas.length === 0) {
        resetPacman();
      }

      // Feedback visual
      if (feedbackTimer > 0) {
        ctx.fillStyle = '#FFFFFF';
        ctx.font = `${cellSize * 0.5}px Arcade Classic`;
        ctx.fillText(feedbackText, canvas.width / 2 - cellSize * 1.5, cellSize);
        feedbackTimer--;
      }

      // Game Over
      if (gameOver) {
        ctx.fillStyle = '#FFFF00';
        ctx.font = `${cellSize * 0.8}px Arcade Classic`;
        ctx.fillText('Jogo Encerrado', canvas.width / 2 - cellSize * 4, canvas.height / 2);
        canvas.classList.remove('active');
        return;
      }

      requestAnimationFrame(loop);
    }

    // Controles
    document.addEventListener('keydown', e => {
      if (!canPlay) return;
      if (e.code === 'KeyW') controles.up = true;
      if (e.code === 'KeyS') controles.down = true;
      if (e.code === 'KeyA') controles.left = true;
      if (e.code === 'KeyD') controles.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.code === 'KeyW') controles.up = false;
      if (e.code === 'KeyS') controles.down = false;
      if (e.code === 'KeyA') controles.left = false;
      if (e.code === 'KeyD') controles.right = false;
    });

    // Inicializa√ß√£o
    resetPacman();
    atualizarStatus();
    if (canPlay && !gameOver) {
      canvas.classList.add('active');
      loop();
    }
  

